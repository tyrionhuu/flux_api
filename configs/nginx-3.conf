# FLUX API Load Balancer Configuration - 3 GPUs
# Distributes requests across 3 GPU instances

# Set worker processes to auto (uses number of CPU cores)
worker_processes auto;

# Optimize for low latency
worker_rlimit_nofile 65535;

events {
    worker_connections 4096;
    use epoll;  # Efficient connection handling on Linux
    multi_accept on;
}

http {
    # Rate limiting zones - prevent overload
    # Reduced rate to prevent overwhelming the backends
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=6r/s;  # 6 req/s for 3 GPUs
    limit_conn_zone $binary_remote_addr zone=addr_limit:10m;
    
    # Define upstream servers - one per GPU (3 GPUs)
    upstream flux_api_backend {
        # Use least connections algorithm for better load distribution
        least_conn;
        
        # CRITICAL: max_conns=1 ensures each GPU processes only 1 request at a time
        # This prevents the blocking issue when multiple requests hit the same backend
        server 127.0.0.1:23333 max_conns=1 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:23334 max_conns=1 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:23335 max_conns=1 max_fails=3 fail_timeout=30s;

        # Keepalive connections for better performance
        keepalive 32;
    }

    server {
    listen 8080;  # Listen on all interfaces
    listen [::]:8080;  # IPv6 support
    server_name _;  # Accept any hostname
    
    # Client body size limit for LoRA uploads (1GB)
    client_max_body_size 1024M;
    
    # Longer timeouts for image generation
    proxy_connect_timeout 600s;
    proxy_send_timeout 600s;
    proxy_read_timeout 600s;
    send_timeout 600s;
    
    # Main API endpoint
    location / {
        # Rate limiting - burst allows temporary spikes but with delays
        # This queues requests at nginx level before sending to backends
        limit_req zone=api_limit burst=100 delay=20;  # Queue up to 20, delay after 6
        limit_conn addr_limit 10;  # Max 10 concurrent connections per IP
        
        # Return 503 when backend is overloaded instead of hanging
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 3;
        
        proxy_pass http://flux_api_backend;
        
        # Pass real client information
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support (if needed for streaming)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Enable buffering to queue requests at nginx level
        # This helps prevent overwhelming the backends
        proxy_buffering on;
        proxy_request_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 8 128k;
        proxy_busy_buffers_size 256k;
        
        # Keep connections alive properly
        proxy_set_header Connection "";
    }
    
    # Health check endpoint (nginx plus feature, or use external monitoring)
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
    
    # Status page (optional, requires nginx stub_status module)
    location /nginx_status {
        stub_status on;
        allow 127.0.0.1;
        deny all;
    }
}

    # Optional: SSL configuration
    # server {
    #     listen 443 ssl http2;
    #     server_name your-domain.com;
    #     
    #     ssl_certificate /path/to/cert.pem;
    #     ssl_certificate_key /path/to/key.pem;
    #     
    #     # ... rest of configuration same as above ...
    # }
}  # Close http block